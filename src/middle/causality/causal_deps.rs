// Copyright 2018 Pierre Talbot (IRCAM)

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at

//     http://www.apache.org/licenses/LICENSE-2.0

// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/// We capture the causal dependencies generated by expression of a spacetime program.
/// It is described in the Section 4.5.4 in the dissertation (Talbot, 2018).

use context::*;
use middle::causality::causal_model::*;

pub struct CausalDeps {}

impl CausalDeps {
  pub fn new() -> Self {
    CausalDeps { }
  }

  pub fn visit_expr(&self, expr: Expr, is_monotonic: bool, model: CausalModel) -> CausalModel {
    use ast::ExprKind::*;
    match expr.node {
      Number(_)
    | StringLiteral(_)
    | Trilean(_)
    | Bottom
    | Top => self.visit_constant(model),
      NewInstance(new_instance) => self.visit_exprs_simultaneously(new_instance.args, is_monotonic, model),
      Call(call) => self.visit_method_call(call, is_monotonic, model),
      Var(var) => self.visit_var(var, is_monotonic, model),
      Or(left, right)
    | And(left, right) => self.visit_bin_op(*left, *right, is_monotonic, model),
      Not(expr) => self.visit_expr(*expr, is_monotonic, model),
      Entailment(rel) => self.visit_entailment(*rel, is_monotonic, model)
    }
  }

  /// Arguments of a function must not be sequentially ordered: it is possible to execute them in any order.
  /// For example: `f(read x, write x)` must fail because we cannot sequentially order the write after the read.
  /// Constraining operations to be simultaneous enforces that these operations are not sequentially ordered.
  fn visit_exprs_simultaneously(&self, exprs: Vec<Expr>, is_monotonic: bool, mut model: CausalModel) -> CausalModel {
    let mut op_models = vec![];
    let mut models = vec![];
    for expr in exprs {
      let is_var = expr.is_var();
      let m = self.visit_expr(expr, is_monotonic, model.clone());
      if is_var {
        op_models.push(m);
      }
      else { models.push(m); }
    }
    model = model.fold(models);
    assert!(op_models.iter().all(|m| m.latest_ops.len() == 1),
      "visit_exprs_simultaneously: variable operation must only create one latest operation.");
    let simultaneous_ops: Vec<usize> = op_models.iter().map(|m| m.latest_ops[0]).collect();
    model = model.fold(op_models);
    model.add_simultaneous_ops_constraint(simultaneous_ops);
    model
  }

  /// We restrict ourselves to binary operations causal with a left-to-right order of evaluation.
  /// This is to simplify the runtime.
  fn visit_bin_op(&self, left: Expr, right: Expr, is_monotonic: bool, model: CausalModel) -> CausalModel {
    let m1 = self.visit_expr(left, is_monotonic, model);
    self.visit_expr(right, is_monotonic, m1)
  }

  fn visit_method_call(&self, call: MethodCall, is_monotonic: bool, model: CausalModel) -> CausalModel {
    assert_eq!(is_monotonic, false,
      "visit_method_call: method can only be called in a non-monotonic context.\n\
      This should be checked in `infer_permission.rs` (E0027).");
    let mut args = call.args;
    // From the point of view of the causality, the target of the method call is just an argument.
    if let Some(target) = call.target {
      args.insert(0, Expr::new(target.span, ExprKind::Var(target)));
    }
    self.visit_exprs_simultaneously(args, is_monotonic, model)
  }

  /// The sub-expressions of the entailment are quite limited:
  /// By the analysis E0026 and E0027 host functions, write and readwrite are forbidden.
  /// Therefore, there is no need to generate sequential constraints between the left and right sides.
  fn visit_entailment(&self, rel: EntailmentRel, is_monotonic: bool, model: CausalModel) -> CausalModel {
    let (l, r) =
      if is_monotonic { (true, false) }
      else { (false, true) };
    let m1 = self.visit_expr(rel.left, l, model.clone());
    let m2 = self.visit_expr(rel.right, r, model);
    m1.join_constraints(m2, CausalModel::term_and)
  }

  pub fn visit_var(&self, var: Variable, is_monotonic: bool, mut model: CausalModel) -> CausalModel {
    if is_monotonic {
      return model;
    }
    model.add_after_latest_constraint(var.op_no);
    model.instantaneous = true;
    model
  }

  fn visit_constant(&self, mut model: CausalModel) -> CausalModel {
    model.instantaneous = true;
    model
  }
}

